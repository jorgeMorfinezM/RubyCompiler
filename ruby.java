/* Generated By:JavaCC: Do not edit this line. ruby.java */
import java.io.*;
import java.lang.*;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.*;

public class ruby implements rubyConstants {
  public FileOutputStream Sint1;
  public DataOutputStream Sint2;
  public FileOutputStream Token1;
  public DataOutputStream Token2;

  public FileOutputStream file;

  public String ar[] = new String[1024];
  public static int error = 0;
  public static int linea;

  public void Escribe(String mensaje)
     {
      archSint_escribe(mensaje);
     }
     
  public ruby(String files)
  {
      try 
      {
            this.file = new FileOutputStream(files);
      } 
      catch(FileNotFoundException ex) 
      {
            //Logger.getLogger(PHP.class.getName()).log(Level.SEVERE, null, ex);
            JOptionPane.showMessageDialog(null, ex, ":: No se encontro el archivo", JOptionPane.ERROR_MESSAGE);
      }
  }
  public void archSint_crear(String nombre_arch)
    {
      try {
           Sint1 = new FileOutputStream(nombre_arch);
           Sint2 = new DataOutputStream(Sint1);
          }
      catch (IOException Ex)
          {
           System.err.println("No se creo el archivo correctamente");
          }
     }
  public void archSint_cerrar()
  {
      try {
           Sint1.close();
          }
      catch (IOException Ex)
          {
           System.err.println("No se cerro corectamente");
          }
  }
  public void archSint_escribe(String Mensaje)
     {
      try {
           Sint2.writeBytes(Mensaje+"\r");
           Sint1.write('\n');
          }
      catch(IOException Ex)
          {
           System.err.println("No se escribio correctamente");
          }
     }


  public void archtoken_crear(String nombre_arch)
  {
    try
    {
      Token1 = new FileOutputStream(nombre_arch);
      Token2 = new DataOutputStream(Token1);
    }
    catch (IOException Ex)
    {
      System.err.println("No se creo el archivo correctamente");
    }
  }
  public void archtoken_cerrar()
  {
    try
    {
      Token1.close();
    }
    catch (IOException Ex)
    {
      System.err.println("No se cerro el archivo corectamente");
    }
   }
  public void archtoken_escribe(String Mensaje)
  {
    try
    {
      Token2.writeBytes(Mensaje+"\r");
      Token1.write('\n');
    }
    catch(IOException Ex)
    {
      System.err.println("No se escribio en el archivo correctamente");
    }
  }
  public void analizarLexico(ruby analiza)
  {
       try
       {
              analiza.archtoken_crear("Lexico.txt");
              analiza.input(analiza);

       }
       catch (ParseException ex) {
            Logger.getLogger(ruby.class.getName()).log(Level.SEVERE, null, ex);
       }
  }

  public void analizarLexico(ruby analiza, String ruta)
  {
       try
       {
             analiza.archtoken_crear(ruta);
             analiza.input(analiza);
       }
       catch(ParseException ex) {
             Logger.getLogger(ruby.class.getName()).log(Level.SEVERE, null, ex);
       }
  }

  public void analizarSintactico(ruby analiza)
  {
       try 
       {
             analiza.archSint_crear("Sintactico.txt");
             linea = 1;
             error = 0;
             analiza.PROGRAMA(analiza);
             if(error == 0)
             {
                   analiza.archSint_escribe("\n :: NO SE HAN ENCONTRADO ERRORRES EN LA COMPILACION::");
                   //System.out.println("\n:: NO SE HAN ENCONTRADO ERRORES ::");
             }
             else
             {
                   analiza.archSint_escribe("\n ***SE HAN ENCONTRADO ERRORES*** ");
                   analiza.archSint_escribe("  Numero de errores: " + error);
                   //System.out.println("\n ****************SE HAN ENCONTRADO ERRORES**************** ");
                   //System.out.println("\n\n Numero de errores: " + error);
             }
             analiza.archSint_escribe(" Numero de lineas: " + linea);
             //System.out.println("\n\n Numero de lineas: " + linea);
             analiza.archSint_cerrar();
        } 
        catch (Exception ex) {
             Logger.getLogger(ruby.class.getName()).log(Level.SEVERE, null, ex);
        }
  }

  public void analizarSintactico(ruby analiza, String ruta)
  {
        try 
        	{
                analiza.archSint_crear(ruta);
                linea = 1;
                error = 0;
                analiza.PROGRAMA(analiza);
                if(error == 0)
                {
                     analiza.archSint_escribe("\n ::NO SE HAN ENCONTRADO ERRORRES EN LA COMPILACION::");
                     //System.out.println("\n:: NO SE HAN ENCONTRADO ERRORES ::");
                }
                else{
                     analiza.archSint_escribe("\n ***SE HAN ENCONTRADO ERRORES*** ");
                     analiza.archSint_escribe(" Numero de errores: " + error);
                     //System.out.println("\n ****************SE HAN ENCONTRADO ERRORES**************** ");
                     //System.out.println("\n\n Numero de errores: " + error);
                }
                analiza.archSint_escribe(" Numero de lineas: " + linea);
                //System.out.println("\n\n Numero de lineas:   " + linea);
                analiza.archSint_cerrar();
        } 
        catch (Exception ex) {
                Logger.getLogger(ruby.class.getName()).log(Level.SEVERE, null, ex);
        }
  }

  public static void main(String args[])   throws ParseException
  {
      ruby analiza;

      if(args.length == 0)
      {
          System.err.println("Uso del programa: \"java RUBY archivo.ejm\"");
      }
      else
      {
          if(args.length == 1)
          {
               try
               {
                    analiza = new ruby (new java.io.FileInputStream(args[0]));
                    analiza.archtoken_crear("Lexico.txt");
                    analiza.input(analiza);
               }
               catch (java.io.FileNotFoundException e)
               {
                    System.out.println("No se pudo leer el archivo: " + args[0] + " ");
               }
               try
               {
               	    analiza = new ruby (new java.io.FileInputStream(args[0]));
                    analiza.archSint_crear("Sintactico.txt");
                    linea = 1;
                    analiza.PROGRAMA(analiza);
                    if(error == 0)
                    {
                         analiza.archSint_escribe("\n:: NO SE HAN ENCONTRADO ERRORES EN LA COMPILACION ::");
                         //System.out.println("\n:: NO SE HAN ENCONTRADO ERRORES ::");
                    }
                    else
                    {
                         analiza.archSint_escribe("\n:: SE HAN ENCONTRADO ERRORES EN LA COMPILACION ::");
                         analiza.archSint_escribe("  Numero de errores: " + error);
                         //System.out.println("\n:: SE HAN ENCONTRADO ERRORES EN LA COMPILACION ::");
                         //System.out.println("\n\n Numero de errores:   " + error);
                    }
                    analiza.archSint_escribe("Numero de lineas: " + linea);
                    //System.out.println("\n\n Numero de lineas:   " + linea);
                    analiza.archSint_cerrar();
               }
               catch (java.io.FileNotFoundException e)
               {
                    System.out.println("No se pudo leer el archivo: " + args[0] + " ");
               }
          }
          else
             {
                  System.out.println("Formato: java ruby nombrearchivo.rb");
             }
      }
  }

 final public void input(ruby analiza) throws ParseException {
                          String mensaje;
    label_1:
    while (true) {
      mensaje = Checa();
       analiza.archtoken_escribe(mensaje);
       System.out.println(mensaje + "\n");
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case palias:
      case pbreak:
      case pcase:
      case pclass:
      case pdef:
      case pdefined:
      case pdo:
      case pelse:
      case pelsif:
      case pend:
      case pensure:
      case pfalse:
      case ptrue:
      case pfor:
      case pif:
      case pin:
      case pmodule:
      case pnext:
      case pnew:
      case pcapitalize:
      case pnil:
      case pretry:
      case preturn:
      case pself:
      case psuper:
      case pthen:
      case pundef:
      case punless:
      case puntil:
      case pwhen:
      case pwhile:
      case pyield:
      case pputs:
      case pprint:
      case pinicio:
      case pchomp:
      case pelseif:
      case pleap:
      case ploop:
      case tiempo:
      case ahora:
      case dia:
      case mes:
      case anio:
      case hora:
      case minuto:
      case segundo:
      case zona:
      case pstring:
      case pinteger:
      case pboolean:
      case preal:
      case prational:
      case pchar:
      case pvar:
      case pconst:
      case parray:
      case peach:
      case pitem:
      case Suma:
      case Resta:
      case Multip:
      case Division:
      case Mod:
      case asignacion:
      case Not:
      case And:
      case Or:
      case XOr:
      case Igual:
      case Desigualdad:
      case MayQue:
      case MenQue:
      case MayIgual:
      case MenIgual:
      case Pertenencia:
      case parenizq:
      case parender:
      case llaveizq:
      case llaveder:
      case corizq:
      case corder:
      case puncoma:
      case dospuntos:
      case coma:
      case punto:
      case subrango:
      case apostrofo:
      case comilla:
      case letramayus:
      case letraminus:
      case letras:
      case digito:
      case caracter:
      case cad:
      case formato:
      case formato_sub:
      case entero:
      case decim:
      case ident:
      case arreglo_uni:
      case arreglo_bid:
      case llamado:
      case cad_noval:
      case sharp_coment:
      case variable_instancia:
      case variable_local:
      case variable_global:
      case constante:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
    }
    jj_consume_token(0);
  }

  final public String Checa() throws ParseException {
                Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case palias:
      t = jj_consume_token(palias);
                 {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pbreak:
      t = jj_consume_token(pbreak);
                {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case preturn:
      t = jj_consume_token(preturn);
                {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pretry:
      t = jj_consume_token(pretry);
                {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pself:
      t = jj_consume_token(pself);
                {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case psuper:
      t = jj_consume_token(psuper);
                {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pthen:
      t = jj_consume_token(pthen);
                {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pinicio:
      t = jj_consume_token(pinicio);
                 {if (true) return ( t.image +"\t\t Inicio ");}
      break;
    case peach:
      t = jj_consume_token(peach);
                 {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pitem:
      t = jj_consume_token(pitem);
                 {if (true) return ( t.image +"\t\t Elemento del arreglo ");}
      break;
    case pelseif:
      t = jj_consume_token(pelseif);
                 {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pstring:
      t = jj_consume_token(pstring);
                 {if (true) return ( t.image +"\t\t Tipo de dato ");}
      break;
    case pconst:
      t = jj_consume_token(pconst);
                 {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pinteger:
      t = jj_consume_token(pinteger);
                 {if (true) return ( t.image +"\t\t Tipo de dato ");}
      break;
    case preal:
      t = jj_consume_token(preal);
             {if (true) return ( t.image +"\t\t Tipo de dato ");}
      break;
    case prational:
      t = jj_consume_token(prational);
                 {if (true) return ( t.image +"\t\t Tipo de dato ");}
      break;
    case pchar:
      t = jj_consume_token(pchar);
             {if (true) return ( t.image +"\t\t Tipo de dato ");}
      break;
    case pvar:
      t = jj_consume_token(pvar);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pboolean:
      t = jj_consume_token(pboolean);
                 {if (true) return ( t.image +"\t\t Tipo de dato ");}
      break;
    case parray:
      t = jj_consume_token(parray);
                 {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pcase:
      t = jj_consume_token(pcase);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pclass:
      t = jj_consume_token(pclass);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pdef:
      t = jj_consume_token(pdef);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pdefined:
      t = jj_consume_token(pdefined);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pdo:
      t = jj_consume_token(pdo);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pelse:
      t = jj_consume_token(pelse);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pelsif:
      t = jj_consume_token(pelsif);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pend:
      t = jj_consume_token(pend);
             {if (true) return ( t.image +"\t\t Palabra reservada o fin de instruccion ");}
      break;
    case pensure:
      t = jj_consume_token(pensure);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pfalse:
      t = jj_consume_token(pfalse);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case ptrue:
      t = jj_consume_token(ptrue);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pfor:
      t = jj_consume_token(pfor);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pif:
      t = jj_consume_token(pif);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pin:
      t = jj_consume_token(pin);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pnil:
      t = jj_consume_token(pnil);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pmodule:
      t = jj_consume_token(pmodule);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pnext:
      t = jj_consume_token(pnext);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pundef:
      t = jj_consume_token(pundef);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case punless:
      t = jj_consume_token(punless);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case puntil:
      t = jj_consume_token(puntil);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pwhen:
      t = jj_consume_token(pwhen);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pwhile:
      t = jj_consume_token(pwhile);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pyield:
      t = jj_consume_token(pyield);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pputs:
      t = jj_consume_token(pputs);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pprint:
      t = jj_consume_token(pprint);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pleap:
      t = jj_consume_token(pleap);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case ploop:
      t = jj_consume_token(ploop);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pnew:
      t = jj_consume_token(pnew);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pcapitalize:
      t = jj_consume_token(pcapitalize);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case pchomp:
      t = jj_consume_token(pchomp);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case tiempo:
      t = jj_consume_token(tiempo);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case ahora:
      t = jj_consume_token(ahora);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case dia:
      t = jj_consume_token(dia);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case mes:
      t = jj_consume_token(mes);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case anio:
      t = jj_consume_token(anio);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case hora:
      t = jj_consume_token(hora);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case minuto:
      t = jj_consume_token(minuto);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case segundo:
      t = jj_consume_token(segundo);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case zona:
      t = jj_consume_token(zona);
             {if (true) return ( t.image +"\t\t Palabra reservada ");}
      break;
    case Suma:
      t = jj_consume_token(Suma);
             {if (true) return ( t.image +"\t\t Operador aritmetico ");}
      break;
    case Mod:
      t = jj_consume_token(Mod);
             {if (true) return ( t.image +"\t\t Operador aritmetico ");}
      break;
    case Resta:
      t = jj_consume_token(Resta);
             {if (true) return ( t.image +"\t\t Operador aritmetico ");}
      break;
    case Multip:
      t = jj_consume_token(Multip);
             {if (true) return ( t.image +"\t\t Operador aritmetico ");}
      break;
    case Division:
      t = jj_consume_token(Division);
             {if (true) return ( t.image +"\t\t Operador aritmetico ");}
      break;
    case asignacion:
      t = jj_consume_token(asignacion);
             {if (true) return ( t.image +"\t\t Operador aritmetico ");}
      break;
    case Not:
      t = jj_consume_token(Not);
             {if (true) return ( t.image +"\t\t Operador logico ");}
      break;
    case And:
      t = jj_consume_token(And);
             {if (true) return ( t.image +"\t\t Operador logico ");}
      break;
    case Or:
      t = jj_consume_token(Or);
             {if (true) return ( t.image +"\t\t Operador logico ");}
      break;
    case XOr:
      t = jj_consume_token(XOr);
             {if (true) return ( t.image +"\t\t Operador logico ");}
      break;
    case Igual:
      t = jj_consume_token(Igual);
             {if (true) return ( t.image +"\t\t Operador relacional ");}
      break;
    case Desigualdad:
      t = jj_consume_token(Desigualdad);
             {if (true) return ( t.image +"\t\t Operador relacional ");}
      break;
    case MayQue:
      t = jj_consume_token(MayQue);
             {if (true) return ( t.image +"\t\t Operador relacional ");}
      break;
    case MenQue:
      t = jj_consume_token(MenQue);
             {if (true) return ( t.image +"\t\t Operador relacional ");}
      break;
    case MayIgual:
      t = jj_consume_token(MayIgual);
             {if (true) return ( t.image +"\t\t Operador relacional ");}
      break;
    case MenIgual:
      t = jj_consume_token(MenIgual);
             {if (true) return ( t.image +"\t\t Operador relacional ");}
      break;
    case Pertenencia:
      t = jj_consume_token(Pertenencia);
             {if (true) return ( t.image +"\t\t Operador relacional ");}
      break;
    case parenizq:
      t = jj_consume_token(parenizq);
             {if (true) return ( t.image +"\t\t parentesis izquierdo ");}
      break;
    case llaveizq:
      t = jj_consume_token(llaveizq);
             {if (true) return ( t.image +"\t\t llave izquierda ");}
      break;
    case llaveder:
      t = jj_consume_token(llaveder);
             {if (true) return ( t.image +"\t\t llave derecha ");}
      break;
    case parender:
      t = jj_consume_token(parender);
             {if (true) return ( t.image +"\t\t parentesis derecho ");}
      break;
    case corizq:
      t = jj_consume_token(corizq);
             {if (true) return ( t.image +"\t\t corchete izquierdo ");}
      break;
    case corder:
      t = jj_consume_token(corder);
             {if (true) return ( t.image +"\t\t corchete derecho ");}
      break;
    case puncoma:
      t = jj_consume_token(puncoma);
             {if (true) return ( t.image +"\t\t delimitador ");}
      break;
    case dospuntos:
      t = jj_consume_token(dospuntos);
             {if (true) return ( t.image +"\t\t dos puntos ");}
      break;
    case coma:
      t = jj_consume_token(coma);
             {if (true) return ( t.image +"\t\t coma ");}
      break;
    case punto:
      t = jj_consume_token(punto);
             {if (true) return ( t.image +"\t\t punto ");}
      break;
    case caracter:
      t = jj_consume_token(caracter);
             {if (true) return ( t.image +"\t\t Caracter ");}
      break;
    case cad:
      t = jj_consume_token(cad);
             {if (true) return ( t.image +"\t\t Cadena ");}
      break;
    case comilla:
      t = jj_consume_token(comilla);
             {if (true) return ( t.image +"\t\t Comillas dobles ");}
      break;
    case apostrofo:
      t = jj_consume_token(apostrofo);
             {if (true) return ( t.image +"\t\t Apostrofo ");}
      break;
    case entero:
      t = jj_consume_token(entero);
             {if (true) return ( t.image +"\t\t Numero Entero ");}
      break;
    case decim:
      t = jj_consume_token(decim);
             {if (true) return ( t.image +"\t\t Numero decimal ");}
      break;
    case ident:
      t = jj_consume_token(ident);
             {if (true) return ( t.image +"\t\t Identificador ");}
      break;
    case cad_noval:
      t = jj_consume_token(cad_noval);
             {if (true) return ( t.image +"\t\t Cadena no valida ");}
      break;
    case subrango:
      t = jj_consume_token(subrango);
             {if (true) return ( t.image +"\t\t subrango de elmentos ");}
      break;
    case sharp_coment:
      t = jj_consume_token(sharp_coment);
             {if (true) return ( t.image +"\t\t sharp ");}
      break;
    case variable_instancia:
      t = jj_consume_token(variable_instancia);
             {if (true) return ( t.image +"\t\t variable de instancia ");}
      break;
    case arreglo_uni:
      t = jj_consume_token(arreglo_uni);
             {if (true) return ( t.image +"\t\t Arreglo o vector ");}
      break;
    case arreglo_bid:
      t = jj_consume_token(arreglo_bid);
             {if (true) return ( t.image +"\t\t Arreglo multidimencional ");}
      break;
    case llamado:
      t = jj_consume_token(llamado);
             {if (true) return ( t.image +"\t\t Llamado ");}
      break;
    case variable_local:
      t = jj_consume_token(variable_local);
             {if (true) return ( t.image +"\t\t variable local ");}
      break;
    case letramayus:
      t = jj_consume_token(letramayus);
                 {if (true) return ( t.image +"\t\t letra mayuscula ");}
      break;
    case letraminus:
      t = jj_consume_token(letraminus);
                 {if (true) return ( t.image +"\t\t letra minuscula ");}
      break;
    case letras:
      t = jj_consume_token(letras);
                 {if (true) return ( t.image +"\t\t letra ");}
      break;
    case digito:
      t = jj_consume_token(digito);
                 {if (true) return ( t.image +"\t\t numero ");}
      break;
    case variable_global:
      t = jj_consume_token(variable_global);
                 {if (true) return ( t.image +"\t\t variable global ");}
      break;
    case constante:
      t = jj_consume_token(constante);
                 {if (true) return ( t.image +"\t\t constante ");}
      break;
    case formato:
      t = jj_consume_token(formato);
                 {if (true) return ( t.image +"\t\t Formato de arreglo ");}
      break;
    case formato_sub:
      t = jj_consume_token(formato_sub);
                 {if (true) return ( t.image +"\t\t Formato de arreglo con subrango ");}
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void PROGRAMA(ruby analiza) throws ParseException {
    try {
      PROGRAMA1();
    } catch (ParseException e) {
   Token t=getToken(0);
   if (t.image=="\n")
   {
      linea++;
   }
   if ((t.image != ";") & (t.image != "end;") & (t.image != "\n"))
   {
    do{
     t=getNextToken();
    }while((t.image != ";") & (t.image != "end;") & (t.image != "\n"));
   }
    }
  }
  final public void PROGRAMA1() throws ParseException {
    try {
      DECLARACIONES();
      CUERPO();
    } catch (ParseException e) {
   Token t=getToken(0);
   if (t.image=="\n")
   {
       linea++;
   }
   if ((t.image != ";") & (t.image != "end;") & (t.image != "\n"))
   {
    do{
     t=getNextToken();
    }while((t.image != ";") & (t.image != "end;") & (t.image != "\n"));
   }
    }
  }

  final public void DECLARACIONES() throws ParseException {
    try {
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case pclass:
        case pdef:
        case pvar:
        case letramayus:
        case constante:
          ;
          break;
        default:
          jj_la1[2] = jj_gen;
          break label_2;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case pvar:
          D_VAR();
          break;
        case letramayus:
        case constante:
          D_CONST();
          break;
        case pdef:
          D_METHOD();
          break;
        case pclass:
          D_CLASS();
          break;
        default:
          jj_la1[3] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (ParseException e) {
        Token t=getToken(0);
                if (t.image=="\n")
                {
                        linea++;
                }
                if ((t.image != ";") & (t.image != "end;") & (t.image != "\n"))
                {
                        do{
                                 t=getNextToken();
                        }while((t.image != ";") & (t.image != "end;") & (t.image != "\n"));
                }
                PROGRAMA1();
    }
  }

  final public void D_VAR() throws ParseException {
   try {
      jj_consume_token(pvar);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ident:
        jj_consume_token(ident);
        break;
      case variable_instancia:
        jj_consume_token(variable_instancia);
        break;
      case variable_local:
        jj_consume_token(variable_local);
        break;
      case variable_global:
        jj_consume_token(variable_global);
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case coma:
          ;
          break;
        default:
          jj_la1[5] = jj_gen;
          break label_3;
        }
        jj_consume_token(coma);
        jj_consume_token(ident);
      }
      jj_consume_token(dospuntos);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case formato:
      case formato_sub:
        DGARRAY();
        break;
      case pstring:
      case pinteger:
      case pboolean:
      case preal:
      case prational:
      case pchar:
      case parray:
        TIPO_DAT();
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(puncoma);
    } catch (ParseException e) {
        System.out.println(" Error en definición de variables, linea: "+linea);
        archSint_escribe(" Error en la declaración de variables, linea: "+linea+".");
        error++;
        Token t=getToken(0);
        if (t.image=="\n")
        {
           linea++;
        }
        if ((t.image != ";") & (t.image != "end;") & (t.image != "\n"))
        {
           do
                   {
              t=getNextToken();
           }
                   while((t.image != ";") & (t.image != "end;") & (t.image != "\n"));
        }
        DECLARACIONES();
    }
  }

  final public void GARRAY() throws ParseException {
  try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case arreglo_uni:
      case arreglo_bid:
        label_4:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case arreglo_uni:
            jj_consume_token(arreglo_uni);
            break;
          case arreglo_bid:
            jj_consume_token(arreglo_bid);
            break;
          default:
            jj_la1[7] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case arreglo_uni:
          case arreglo_bid:
            ;
            break;
          default:
            jj_la1[8] = jj_gen;
            break label_4;
          }
        }
        jj_consume_token(puncoma);
        break;
      case variable_instancia:
        jj_consume_token(variable_instancia);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case formato:
          label_5:
          while (true) {
            jj_consume_token(formato);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case formato:
              ;
              break;
            default:
              jj_la1[9] = jj_gen;
              break label_5;
            }
          }
          break;
        case formato_sub:
          label_6:
          while (true) {
            jj_consume_token(formato_sub);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case formato_sub:
              ;
              break;
            default:
              jj_la1[10] = jj_gen;
              break label_6;
            }
          }
          break;
        default:
          jj_la1[11] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(puncoma);
        break;
      case variable_local:
        jj_consume_token(variable_local);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case formato:
          label_7:
          while (true) {
            jj_consume_token(formato);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case formato:
              ;
              break;
            default:
              jj_la1[12] = jj_gen;
              break label_7;
            }
          }
          break;
        case formato_sub:
          label_8:
          while (true) {
            jj_consume_token(formato_sub);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case formato_sub:
              ;
              break;
            default:
              jj_la1[13] = jj_gen;
              break label_8;
            }
          }
          break;
        default:
          jj_la1[14] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(puncoma);
        break;
      case variable_global:
        jj_consume_token(variable_global);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case formato:
          label_9:
          while (true) {
            jj_consume_token(formato);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case formato:
              ;
              break;
            default:
              jj_la1[15] = jj_gen;
              break label_9;
            }
          }
          break;
        case formato_sub:
          label_10:
          while (true) {
            jj_consume_token(formato_sub);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case formato_sub:
              ;
              break;
            default:
              jj_la1[16] = jj_gen;
              break label_10;
            }
          }
          break;
        default:
          jj_la1[17] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(puncoma);
        break;
      default:
        jj_la1[18] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
        System.out.println(" Error en definión de arreglo, línea: "+linea);
        archSint_escribe(" Error en la decraración de arreglo, linea: "+linea+".");
        Token t=getToken(0);
        error++;
        if (t.image=="\n")
        {
           linea++;
        }
        if ((t.image != ";") & (t.image != "end;") & (t.image != "\n"))
        {
           do
                   {
              t=getNextToken();
           }
                   while((t.image != ";") & (t.image != "end;") & (t.image != "\n"));
        }
        D_VAR();
    }
  }

  final public void TIPO_DAT() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case pchar:
      jj_consume_token(pchar);
      break;
    case pinteger:
      jj_consume_token(pinteger);
      break;
    case pboolean:
      jj_consume_token(pboolean);
      break;
    case preal:
      jj_consume_token(preal);
      break;
    case pstring:
      jj_consume_token(pstring);
      break;
    case prational:
      jj_consume_token(prational);
      break;
    case parray:
      jj_consume_token(parray);
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void D_CONST() throws ParseException {
   try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case letramayus:
        label_11:
        while (true) {
          jj_consume_token(letramayus);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case letramayus:
            ;
            break;
          default:
            jj_la1[20] = jj_gen;
            break label_11;
          }
        }
        jj_consume_token(asignacion);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case caracter:
          jj_consume_token(caracter);
          break;
        case cad:
          jj_consume_token(cad);
          break;
        case entero:
          jj_consume_token(entero);
          break;
        case decim:
          jj_consume_token(decim);
          break;
        case arreglo_uni:
          jj_consume_token(arreglo_uni);
          break;
        case arreglo_bid:
          jj_consume_token(arreglo_bid);
          break;
        default:
          jj_la1[21] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(puncoma);
        break;
      case constante:
        jj_consume_token(constante);
        jj_consume_token(puncoma);
        break;
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
         System.out.println(" Error en definición de constantes, línea: "+linea);
         archSint_escribe(" Error en la declaración de constantes, linea: "+linea+".");
         Token t=getToken(0);
         error++;
        if (t.image=="\n")
        {
           linea++;
        }
        if ((t.image != ";") & (t.image != "end;") & (t.image != "\n"))
        {
           do{
                t=getNextToken();
           }
                   while((t.image != ";") & (t.image != "end;") & (t.image != "\n"));
        }
        DECLARACIONES();
    }
  }

  final public void DGARRAY() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case formato:
      jj_consume_token(formato);
      break;
    case formato_sub:
      jj_consume_token(formato_sub);
      break;
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void VALOR() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case caracter:
      jj_consume_token(caracter);
      break;
    case cad:
      jj_consume_token(cad);
      break;
    case entero:
      jj_consume_token(entero);
      break;
    case decim:
      jj_consume_token(decim);
      break;
    case arreglo_uni:
      jj_consume_token(arreglo_uni);
      break;
    case arreglo_bid:
      jj_consume_token(arreglo_bid);
      break;
    case llamado:
      jj_consume_token(llamado);
      break;
    case variable_instancia:
      jj_consume_token(variable_instancia);
      break;
    case variable_local:
      jj_consume_token(variable_local);
      break;
    case variable_global:
      jj_consume_token(variable_global);
      break;
    case pfalse:
      jj_consume_token(pfalse);
      break;
    case ptrue:
      jj_consume_token(ptrue);
      break;
    case constante:
      jj_consume_token(constante);
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void OPARI() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Suma:
      jj_consume_token(Suma);
      break;
    case Resta:
      jj_consume_token(Resta);
      break;
    case Multip:
      jj_consume_token(Multip);
      break;
    case Division:
      jj_consume_token(Division);
      break;
    case Mod:
      jj_consume_token(Mod);
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void OPREL() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Igual:
      jj_consume_token(Igual);
      break;
    case Desigualdad:
      jj_consume_token(Desigualdad);
      break;
    case MayQue:
      jj_consume_token(MayQue);
      break;
    case MenQue:
      jj_consume_token(MenQue);
      break;
    case MayIgual:
      jj_consume_token(MayIgual);
      break;
    case MenIgual:
      jj_consume_token(MenIgual);
      break;
    case Pertenencia:
      jj_consume_token(Pertenencia);
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void OPELOG() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Not:
      jj_consume_token(Not);
      break;
    case And:
      jj_consume_token(And);
      break;
    case Or:
      jj_consume_token(Or);
      break;
    case XOr:
      jj_consume_token(XOr);
      break;
    default:
      jj_la1[27] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void D_METHOD() throws ParseException {
    try {
      jj_consume_token(pdef);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case letraminus:
        label_12:
        while (true) {
          jj_consume_token(letraminus);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case letraminus:
            ;
            break;
          default:
            jj_la1[28] = jj_gen;
            break label_12;
          }
        }
        break;
      case ident:
        jj_consume_token(ident);
        break;
      default:
        jj_la1[29] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case parenizq:
        PARAMET();
        break;
      default:
        jj_la1[30] = jj_gen;
        ;
      }
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case pfor:
        case pif:
        case pwhile:
        case pputs:
        case pprint:
        case pleap:
        case ident:
          ;
          break;
        default:
          jj_la1[31] = jj_gen;
          break label_13;
        }
        INSTRUCCIONES();
      }
      jj_consume_token(pend);
      jj_consume_token(puncoma);
    } catch (ParseException e) {
        System.out.println(" Error en definición del método, línea: "+linea);
        archSint_escribe(" Error en la declaración del método, linea: "+linea+".");
        Token t=getToken(0);
        error++;
                if (t.image=="\n")
                {
                        linea++;
                }
                if ((t.image != ";") & (t.image != "end;") & (t.image != "\n"))
                {
                        do{
                                t=getNextToken();
                        }
                        while((t.image != ";") & (t.image != "end;") & (t.image != "\n"));
                }
                DECLARACIONES();
    }
  }

  final public void PARAMET() throws ParseException {
    try {
      jj_consume_token(parenizq);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case pfalse:
      case ptrue:
      case caracter:
      case cad:
      case entero:
      case decim:
      case llamado:
      case variable_instancia:
      case variable_local:
      case variable_global:
      case constante:
        label_14:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case caracter:
            jj_consume_token(caracter);
            break;
          case cad:
            jj_consume_token(cad);
            break;
          case entero:
            jj_consume_token(entero);
            break;
          case decim:
            jj_consume_token(decim);
            break;
          case llamado:
            jj_consume_token(llamado);
            break;
          case variable_instancia:
            jj_consume_token(variable_instancia);
            break;
          case variable_local:
            jj_consume_token(variable_local);
            break;
          case variable_global:
            jj_consume_token(variable_global);
            break;
          case pfalse:
            jj_consume_token(pfalse);
            break;
          case ptrue:
            jj_consume_token(ptrue);
            break;
          case constante:
            jj_consume_token(constante);
            break;
          default:
            jj_la1[32] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case coma:
            jj_consume_token(coma);
            break;
          default:
            jj_la1[33] = jj_gen;
            ;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case pfalse:
          case ptrue:
          case caracter:
          case cad:
          case entero:
          case decim:
          case llamado:
          case variable_instancia:
          case variable_local:
          case variable_global:
          case constante:
            ;
            break;
          default:
            jj_la1[34] = jj_gen;
            break label_14;
          }
        }
        break;
      case ident:
      case arreglo_uni:
      case arreglo_bid:
        label_15:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ident:
            jj_consume_token(ident);
            break;
          case arreglo_uni:
            jj_consume_token(arreglo_uni);
            break;
          case arreglo_bid:
            jj_consume_token(arreglo_bid);
            break;
          default:
            jj_la1[35] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case coma:
            jj_consume_token(coma);
            break;
          default:
            jj_la1[36] = jj_gen;
            ;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ident:
          case arreglo_uni:
          case arreglo_bid:
            ;
            break;
          default:
            jj_la1[37] = jj_gen;
            break label_15;
          }
        }
        break;
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(parender);
    } catch (ParseException e) {
                System.out.println(" Error en la definicion de parámetros, línea: "+linea);
                archSint_escribe(" Error en la declaración de parámetros, linea: "+linea+".");
                Token t=getToken(0);
                error++;
                if (t.image=="\n")
                {
                        linea++;
                }
                if ((t.image != ";") & (t.image != "end;") & (t.image != "\n"))
                {
                        do{
                                 t=getNextToken();
                        }
                        while((t.image != ";") & (t.image != "end;") & (t.image != "\n"));
                }
                DECLARACIONES();
    }
  }

  final public void D_CLASS() throws ParseException {
    try {
      jj_consume_token(pclass);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case letramayus:
        label_16:
        while (true) {
          jj_consume_token(letramayus);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case letramayus:
            ;
            break;
          default:
            jj_la1[39] = jj_gen;
            break label_16;
          }
        }
        label_17:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case letraminus:
            ;
            break;
          default:
            jj_la1[40] = jj_gen;
            break label_17;
          }
          jj_consume_token(letraminus);
        }
        break;
      case ident:
        jj_consume_token(ident);
        break;
      default:
        jj_la1[41] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_18:
      while (true) {
        D_METHOD();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case pdef:
          ;
          break;
        default:
          jj_la1[42] = jj_gen;
          break label_18;
        }
      }
      label_19:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case pfalse:
        case ptrue:
        case caracter:
        case cad:
        case entero:
        case decim:
        case ident:
        case arreglo_uni:
        case arreglo_bid:
        case llamado:
        case variable_instancia:
        case variable_local:
        case variable_global:
        case constante:
          ;
          break;
        default:
          jj_la1[43] = jj_gen;
          break label_19;
        }
        OPERACIONES();
      }
      jj_consume_token(pend);
      jj_consume_token(puncoma);
    } catch (ParseException e) {
        System.out.println(" Error en definición de la clase, línea: "+linea);
        archSint_escribe(" Error en la declaración de la clase, linea: "+linea+".");
        Token t=getToken(0);
        error++;
                if (t.image=="\n")
                {
                        linea++;
                }
                if ((t.image != ";") & (t.image != "end;") & (t.image != "\n"))
            {
                        do{
                                t=getNextToken();
                        }
                        while((t.image != ";") & (t.image != "end;") & (t.image != "\n"));
                }
                DECLARACIONES();
    }
  }

  final public void CUERPO() throws ParseException {
    try {
      INSTRUCCIONES();
    } catch (ParseException e) {
                Token t=getToken(0);
                if (t.image=="\n")
                {
                        linea++;
                }
                if ((t.image != ";") & (t.image != "end;") & (t.image != "\n"))
                {
                        do{
                                t=getNextToken();
                        }
                        while((t.image != ";") & (t.image != "end;") & (t.image != "\n"));
                }
    }
  }

  final public void OPERACIONES() throws ParseException {
      try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case pfalse:
      case ptrue:
      case entero:
      case decim:
      case ident:
      case arreglo_uni:
      case arreglo_bid:
      case llamado:
      case variable_instancia:
      case variable_local:
      case variable_global:
      case constante:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ident:
          jj_consume_token(ident);
          break;
        case entero:
          jj_consume_token(entero);
          break;
        case decim:
          jj_consume_token(decim);
          break;
        case arreglo_uni:
          jj_consume_token(arreglo_uni);
          break;
        case arreglo_bid:
          jj_consume_token(arreglo_bid);
          break;
        case llamado:
          jj_consume_token(llamado);
          break;
        case variable_instancia:
          jj_consume_token(variable_instancia);
          break;
        case variable_local:
          jj_consume_token(variable_local);
          break;
        case variable_global:
          jj_consume_token(variable_global);
          break;
        case pfalse:
          jj_consume_token(pfalse);
          break;
        case ptrue:
          jj_consume_token(ptrue);
          break;
        case constante:
          jj_consume_token(constante);
          break;
        default:
          jj_la1[44] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Suma:
        case Resta:
        case Multip:
        case Division:
        case Mod:
          OPARI();
          break;
        case Igual:
        case Desigualdad:
        case MayQue:
        case MenQue:
        case MayIgual:
        case MenIgual:
        case Pertenencia:
          OPREL();
          break;
        case Not:
        case And:
        case Or:
        case XOr:
          OPELOG();
          break;
        default:
          jj_la1[45] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case entero:
          jj_consume_token(entero);
          break;
        case decim:
          jj_consume_token(decim);
          break;
        case arreglo_uni:
          jj_consume_token(arreglo_uni);
          break;
        case arreglo_bid:
          jj_consume_token(arreglo_bid);
          break;
        case llamado:
          jj_consume_token(llamado);
          break;
        case variable_instancia:
          jj_consume_token(variable_instancia);
          break;
        case variable_local:
          jj_consume_token(variable_local);
          break;
        case variable_global:
          jj_consume_token(variable_global);
          break;
        case constante:
          jj_consume_token(constante);
          break;
        case ident:
          jj_consume_token(ident);
          break;
        default:
          jj_la1[46] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case caracter:
      case cad:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case cad:
          jj_consume_token(cad);
          break;
        case caracter:
          jj_consume_token(caracter);
          break;
        default:
          jj_la1[47] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(Suma);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case cad:
          jj_consume_token(cad);
          break;
        case caracter:
          jj_consume_token(caracter);
          break;
        default:
          jj_la1[48] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[49] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(puncoma);
    } catch (ParseException e) {
                System.out.println("Error en la definición de la operación, linea: "+linea);
                archSint_escribe(" Error en la declaración de la operación, linea: "+linea+".");
                Token t=getToken(0);
                error++;
                if (t.image=="\n")
                {
                        linea++;
                }
                if ((t.image != ";") & (t.image != "end;") & (t.image != "\n"))
                {
                        do{
                                 t=getNextToken();
                        }
                        while((t.image != ";") & (t.image != "end;") & (t.image != "\n"));
                }
    }
  }

  final public void INSTRUCCIONES() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case pputs:
    case pprint:
      MENSAJE();
      break;
    case ident:
      ASIGNA();
      break;
    case pfor:
    case pif:
    case pwhile:
    case pleap:
      CICLOS();
      break;
    default:
      jj_la1[50] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void MENSAJE() throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case pputs:
        jj_consume_token(pputs);
        break;
      case pprint:
        jj_consume_token(pprint);
        break;
      default:
        jj_la1[51] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case parenizq:
        jj_consume_token(parenizq);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ident:
          jj_consume_token(ident);
          break;
        case cad:
          jj_consume_token(cad);
          break;
        case caracter:
          jj_consume_token(caracter);
          break;
        case entero:
          jj_consume_token(entero);
          break;
        case decim:
          jj_consume_token(decim);
          break;
        case arreglo_uni:
          jj_consume_token(arreglo_uni);
          break;
        case arreglo_bid:
          jj_consume_token(arreglo_bid);
          break;
        case llamado:
          jj_consume_token(llamado);
          break;
        case variable_instancia:
          jj_consume_token(variable_instancia);
          break;
        case variable_local:
          jj_consume_token(variable_local);
          break;
        case variable_global:
          jj_consume_token(variable_global);
          break;
        case pfalse:
          jj_consume_token(pfalse);
          break;
        case ptrue:
          jj_consume_token(ptrue);
          break;
        case constante:
          jj_consume_token(constante);
          break;
        default:
          jj_la1[52] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        label_20:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case Suma:
          case Resta:
          case Multip:
          case Division:
          case Mod:
            ;
            break;
          default:
            jj_la1[53] = jj_gen;
            break label_20;
          }
          OPARI();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ident:
            jj_consume_token(ident);
            break;
          case entero:
            jj_consume_token(entero);
            break;
          case decim:
            jj_consume_token(decim);
            break;
          case arreglo_uni:
            jj_consume_token(arreglo_uni);
            break;
          case arreglo_bid:
            jj_consume_token(arreglo_bid);
            break;
          case llamado:
            jj_consume_token(llamado);
            break;
          case variable_instancia:
            jj_consume_token(variable_instancia);
            break;
          case variable_local:
            jj_consume_token(variable_local);
            break;
          case variable_global:
            jj_consume_token(variable_global);
            break;
          case pfalse:
            jj_consume_token(pfalse);
            break;
          case ptrue:
            jj_consume_token(ptrue);
            break;
          case constante:
            jj_consume_token(constante);
            break;
          default:
            jj_la1[54] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        jj_consume_token(parender);
        break;
      case pfalse:
      case ptrue:
      case caracter:
      case cad:
      case entero:
      case decim:
      case ident:
      case arreglo_uni:
      case arreglo_bid:
      case llamado:
      case variable_instancia:
      case variable_local:
      case variable_global:
      case constante:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ident:
          jj_consume_token(ident);
          break;
        case cad:
          jj_consume_token(cad);
          break;
        case caracter:
          jj_consume_token(caracter);
          break;
        case entero:
          jj_consume_token(entero);
          break;
        case decim:
          jj_consume_token(decim);
          break;
        case arreglo_uni:
          jj_consume_token(arreglo_uni);
          break;
        case arreglo_bid:
          jj_consume_token(arreglo_bid);
          break;
        case llamado:
          jj_consume_token(llamado);
          break;
        case variable_instancia:
          jj_consume_token(variable_instancia);
          break;
        case variable_local:
          jj_consume_token(variable_local);
          break;
        case variable_global:
          jj_consume_token(variable_global);
          break;
        case pfalse:
          jj_consume_token(pfalse);
          break;
        case ptrue:
          jj_consume_token(ptrue);
          break;
        case constante:
          jj_consume_token(constante);
          break;
        default:
          jj_la1[55] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        label_21:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case Suma:
          case Resta:
          case Multip:
          case Division:
          case Mod:
            ;
            break;
          default:
            jj_la1[56] = jj_gen;
            break label_21;
          }
          OPARI();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ident:
            jj_consume_token(ident);
            break;
          case entero:
            jj_consume_token(entero);
            break;
          case decim:
            jj_consume_token(decim);
            break;
          case arreglo_uni:
            jj_consume_token(arreglo_uni);
            break;
          case arreglo_bid:
            jj_consume_token(arreglo_bid);
            break;
          case llamado:
            jj_consume_token(llamado);
            break;
          case variable_instancia:
            jj_consume_token(variable_instancia);
            break;
          case variable_local:
            jj_consume_token(variable_local);
            break;
          case variable_global:
            jj_consume_token(variable_global);
            break;
          case pfalse:
            jj_consume_token(pfalse);
            break;
          case ptrue:
            jj_consume_token(ptrue);
            break;
          case constante:
            jj_consume_token(constante);
            break;
          default:
            jj_la1[57] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        jj_la1[58] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(puncoma);
    } catch (ParseException e) {
                System.out.println("\r"+"\n"+"Error en el mensaje, línea: " +linea);
        archSint_escribe(" Error en el mensaje, linea: "+linea+".");
                Token t=getToken(0);
                error++;
                if (t.image=="\n")
                {
                        linea++;
                }
                if ((t.image != ";") & (t.image != "end;") & (t.image != "\n"))
                {
                        do{
                                 t=getNextToken();
                        }while((t.image != ";") & (t.image != "end;") & (t.image != "\n"));
                }
                INSTRUCCIONES();
    }
  }

  final public void ASIGNA() throws ParseException {
    try {
      jj_consume_token(ident);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case formato:
      case formato_sub:
        DGARRAY();
        break;
      default:
        jj_la1[59] = jj_gen;
        ;
      }
      jj_consume_token(asignacion);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case pfalse:
      case ptrue:
      case caracter:
      case cad:
      case entero:
      case decim:
      case arreglo_uni:
      case arreglo_bid:
      case llamado:
      case variable_instancia:
      case variable_local:
      case variable_global:
      case constante:
        VALOR();
        label_22:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case Suma:
          case Resta:
          case Multip:
          case Division:
          case Mod:
            ;
            break;
          default:
            jj_la1[60] = jj_gen;
            break label_22;
          }
          OPARI();
          VALOR();
        }
        jj_consume_token(puncoma);
        break;
      case parenizq:
        jj_consume_token(parenizq);
        VALOR();
        label_23:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case Suma:
          case Resta:
          case Multip:
          case Division:
          case Mod:
            ;
            break;
          default:
            jj_la1[61] = jj_gen;
            break label_23;
          }
          OPARI();
          VALOR();
        }
        jj_consume_token(parender);
        jj_consume_token(puncoma);
        break;
      default:
        jj_la1[62] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
                System.out.println(" Error en la asignación, línea: "+linea);
        archSint_escribe(" Error en la asignacion, linea: "+linea+".");
        Token t=getToken(0);
        error++;
                if (t.image=="\n")
                {
                        linea++;
                }
                if ((t.image != ";") & (t.image != "end;") & (t.image != "\n"))
                {
                        do{
                                 t=getNextToken();
                        }
                        while((t.image != ";") & (t.image != "end;") & (t.image != "\n"));
                }
                INSTRUCCIONES();
    }
  }

  final public void GCASE() throws ParseException {
    try {
      jj_consume_token(pleap);
      jj_consume_token(asignacion);
      jj_consume_token(pcase);
      label_23:
      while (true) {
        jj_consume_token(pwhen);
        OPERACIONES();
        jj_consume_token(pthen);
        OPERACIONES();
        jj_consume_token(puncoma);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case pwhen:
          ;
          break;
        default:
          jj_la1[63] = jj_gen;
          break label_23;
        }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case pelse:
        label_24:
        while (true) {
          jj_consume_token(pelse);
          OPERACIONES();
          jj_consume_token(puncoma);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case pelse:
            ;
            break;
          default:
            jj_la1[64] = jj_gen;
            break label_24;
          }
        }
        break;
      default:
        jj_la1[65] = jj_gen;
        ;
      }
      jj_consume_token(pend);
      jj_consume_token(puncoma);
      jj_consume_token(pputs);
      jj_consume_token(pleap);
      jj_consume_token(puncoma);
    } catch (ParseException e) {
                System.out.println("\r"+"\n"+"Error en CASE línea:" +linea);
                archSint_escribe(" Error en el CASE línea: "+linea+".");
                Token t=getToken(0);
                error++;
                if (t.image=="\n")
                {
                        linea++;
                }
                if ((t.image != ";") & (t.image != "end;") & (t.image != "\n"))
                {
                        do{
                                 t=getNextToken();
                        }
                        while((t.image != ";") & (t.image != "end;") & (t.image != "\n"));
                }
        CICLOS();
    }
  }

  final public void CICLOS() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case pwhile:
      GWHILE();
      break;
    case pif:
      GIFEND();
      break;
    case pleap:
      GCASE();
      break;
    case pfor:
      GFOR();
      break;
    default:
      jj_la1[66] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void GWHILE() throws ParseException {
    try {
      jj_consume_token(pwhile);
      CONDICION();
      label_25:
      while (true) {
        INSTRUCCIONES();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case pfor:
        case pif:
        case pwhile:
        case pputs:
        case pprint:
        case pleap:
        case ident:
          ;
          break;
        default:
          jj_la1[67] = jj_gen;
          break label_25;
        }
      }
      jj_consume_token(pend);
      jj_consume_token(puncoma);
    } catch (ParseException e) {
                System.out.println("\r"+"\n"+"Error en el WHILE línea:" +linea);
                archSint_escribe(" Error en el WHILE línea: "+linea+".");
                Token t=getToken(0);
                error++;
                if(t.image=="\n")
                {
                        linea++;
                }
                if((t.image != ";") & (t.image != "end;") & (t.image != "\n"))
                {
                        do{
                                 t=getNextToken();
                        }
                        while((t.image != ";") & (t.image != "end;") & (t.image != "\n"));
                }
                CICLOS();
    }
  }

  final public void CONDICION() throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case pfalse:
      case ptrue:
      case caracter:
      case cad:
      case entero:
      case decim:
      case arreglo_uni:
      case arreglo_bid:
      case llamado:
      case variable_instancia:
      case variable_local:
      case variable_global:
      case constante:
        VALOR();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Igual:
        case Desigualdad:
        case MayQue:
        case MenQue:
        case MayIgual:
        case MenIgual:
        case Pertenencia:
          OPREL();
          VALOR();
          break;
        default:
          jj_la1[68] = jj_gen;
          ;
        }
        break;
      case parenizq:
        jj_consume_token(parenizq);
        VALOR();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Igual:
        case Desigualdad:
        case MayQue:
        case MenQue:
        case MayIgual:
        case MenIgual:
        case Pertenencia:
          OPREL();
          VALOR();
          break;
        default:
          jj_la1[69] = jj_gen;
          ;
        }
        jj_consume_token(parender);
        label_26:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case Not:
          case And:
          case Or:
          case XOr:
            ;
            break;
          default:
            jj_la1[70] = jj_gen;
            break label_26;
          }
          OPELOG();
          jj_consume_token(parenizq);
          VALOR();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case Igual:
          case Desigualdad:
          case MayQue:
          case MenQue:
          case MayIgual:
          case MenIgual:
          case Pertenencia:
            OPREL();
            VALOR();
            break;
          default:
            jj_la1[71] = jj_gen;
            ;
          }
          jj_consume_token(parender);
        }
        break;
      default:
        jj_la1[72] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
                System.out.println("\r"+"\n"+"Error en la condicion, línea: " +linea);
                archSint_escribe(" Error en la condición, línea: "+linea+".");
                Token t=getToken(0);
                error++;
                if(t.image=="\n")
                {
                        linea++;
                }
                if((t.image != ";") & (t.image != "end;") & (t.image != "\n"))
                {
                        do{
                                 t=getNextToken();
                        }
                        while((t.image != ";") & (t.image != "end;") & (t.image != "\n"));
                }
    }
  }

  final public void GIFEND() throws ParseException {
    try {
      jj_consume_token(pif);
      CONDICION();
      label_27:
      while (true) {
        INSTRUCCIONES();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case pfor:
        case pif:
        case pwhile:
        case pputs:
        case pprint:
        case pleap:
        case ident:
          ;
          break;
        default:
          jj_la1[73] = jj_gen;
          break label_27;
        }
      }
      jj_consume_token(pend);
      jj_consume_token(puncoma);
      label_28:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case pelse:
          ;
          break;
        default:
          jj_la1[74] = jj_gen;
          break label_28;
        }
        GELSE();
      }
    } catch (ParseException e) {
                System.out.println("\r"+"\n"+"Error en IF, línea: " +linea);
                archSint_escribe(" Error en el IF, línea: "+linea+".");
                error++;
                Token t=getToken(0);
                if (t.image=="\n")
                {
                        linea++;
                }
                if ((t.image != ";") & (t.image != "end;") & (t.image != "\n"))
                {
                        do{
                                 t=getNextToken();
                        }
                        while((t.image != ";") & (t.image != "end;") & (t.image != "\n"));
                }
                CICLOS();
    }
  }

  final public void GELSE() throws ParseException {
    try {
      jj_consume_token(pelse);
      label_29:
      while (true) {
        INSTRUCCIONES();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case pfor:
        case pif:
        case pwhile:
        case pputs:
        case pprint:
        case pleap:
        case ident:
          ;
          break;
        default:
          jj_la1[75] = jj_gen;
          break label_29;
        }
      }
      jj_consume_token(pend);
      jj_consume_token(puncoma);
    } catch (ParseException e) {
                System.out.println("\r"+"\n"+"Error en ELSE, línea: " +linea);
                archSint_escribe(" Error en el ELSE, línea: "+linea+".");
                Token t=getToken(0);
                error++;
                if (t.image=="\n")
                {
                        linea++;
                }
                if ((t.image != ";") & (t.image != "end;") & (t.image != "\n"))
                {
                        do{
                                 t=getNextToken();
                        }
                        while((t.image != ";") & (t.image != "end;") & (t.image != "\n"));
                }
                GIFEND();
    }
  }

  final public void GFOR() throws ParseException {
    try {
      jj_consume_token(pfor);
      jj_consume_token(ident);
      jj_consume_token(Pertenencia);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case formato:
        jj_consume_token(formato);
        break;
      case formato_sub:
        jj_consume_token(formato_sub);
        break;
      default:
        jj_la1[76] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_30:
      while (true) {
        INSTRUCCIONES();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case pfor:
        case pif:
        case pwhile:
        case pputs:
        case pprint:
        case pleap:
        case ident:
          ;
          break;
        default:
          jj_la1[77] = jj_gen;
          break label_30;
        }
      }
      jj_consume_token(pend);
      jj_consume_token(puncoma);
    } catch (ParseException e) {
                System.out.println("\r"+"\n"+"Error en FOR, línea: " +linea);
                archSint_escribe(" Error en el FOR, línea: "+linea+".");
                Token t=getToken(0);
                error++;
                if(t.image=="\n")
                {
                        linea++;
                }
                if((t.image != ";") & (t.image != "end;") & (t.image != "\n"))
                {
                        do{
                                 t=getNextToken();
                        }
                        while((t.image != ";") & (t.image != "end;") & (t.image != "\n"));
                }
                CICLOS();
    }
  }

  private boolean jj_initialized_once = false;
  public rubyTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[78];
  final private int[] jj_la1_0 = {0xffffffe0,0xffffffe0,0x300,0x300,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x30000,0x0,0x0,0x0,0x0,0x0,0x0,0x30000,0x30000,0x0,0x30000,0x0,0x0,0x0,0x30000,0x0,0x0,0x0,0x200,0xc0000,0x30000,0x0,0x0,0x0,0x0,0x30000,0xc0000,0x0,0x30000,0x0,0x30000,0x30000,0x0,0x30000,0x30000,0x0,0x0,0x0,0x30000,0x0,0x1000,0x1000,0xc0000,0xc0000,0x0,0x0,0x0,0x0,0x30000,0xc0000,0x1000,0xc0000,0x0,0xc0000,};
  final private int[] jj_la1_1 = {0xffffffff,0xffffffff,0x8000000,0x8000000,0x0,0x27e00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x27e00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x468,0x0,0x0,0x0,0x0,0x0,0x0,0x468,0x60,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x408,0x468,0x0,0x0,0x0,0x0,0x0,0x468,0x0,0x468,0x0,0x468,};
  final private int[] jj_la1_2 = {0x9fffffff,0x9fffffff,0x0,0x0,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0x1fc00,0x3c0,0x0,0x0,0x20000,0x0,0x0,0x2000000,0x0,0x0,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1ffdf,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0x0,0x0,0x1f,0x0,0x20000,0x0,0x1f,0x1f,0x20000,0x0,0x0,0x0,0x0,0x0,0x1fc00,0x1fc00,0x3c0,0x1fc00,0x20000,0x0,0x0,0x0,0x0,0x0,};
  final private int[] jj_la1_3 = {0xfffff,0xfffff,0x80001,0x80001,0x0,0xc0,0x70400,0x1800,0x1800,0x40,0x80,0xc0,0x40,0x80,0xc0,0x40,0x80,0xc0,0x71800,0x0,0x1,0x1b30,0x80001,0xc0,0xf3b30,0x0,0x0,0x0,0x2,0x402,0x0,0xf3f30,0xf2330,0x0,0xf2330,0x1c00,0x0,0x1c00,0xf3f30,0x3,0x3,0x400,0x0,0x400,0xf3f00,0x0,0xf3f00,0x30,0x30,0xf3f30,0x400,0x0,0xf3f30,0x0,0xf3f00,0xf3f30,0x0,0xf3f00,0xf3f30,0xc0,0x0,0x0,0xf3b30,0x0,0x0,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0xf3b30,0x400,0x0,0x400,0xc0,0x400,};

  /*
  public ruby(java.io.InputStream stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new rubyTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 78; i++) jj_la1[i] = -1;
  }
  */

  public ruby(java.io.InputStream stream) 
  {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
   
    //jj_initialized_once = true;
    
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new rubyTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 0; i++) jj_la1[i] = -1;
    //for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }
  
  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 78; i++) jj_la1[i] = -1;
  }

  public ruby(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new rubyTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 78; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 78; i++) jj_la1[i] = -1;
  }

  public ruby(rubyTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 78; i++) jj_la1[i] = -1;
  }

  public void ReInit(rubyTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 78; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  final public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[116];
    for (int i = 0; i < 116; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 78; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 116; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
